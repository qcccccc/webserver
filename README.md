### 本项目实现了以下功能：
1. 解析Http报文，支持GET请求，支持长/短连接。
2. 使用Epoll边沿触发的IO多路复用技术，非阻塞IO，使用Proactor模式。
3. 使用多线程充分利用CPU,并使用线程池避免线程频繁创建销毁的开销。
4. 利用小根堆的定时器关闭超时请求，解决超时，连接系统资源占用问题。

### 互斥锁的使用：
1. 请求任务队列的添加和取操作得加上锁
2. 定时器的增加和删除（主线程和工作线程都会对堆进行操作）

### IO模型:
网络涉及了用户空间和内核空间
1. 等待数据准备就绪，即等待数据被copy到内核缓冲区
2. 等待数据被从内核缓冲区copy到用户缓冲区

### 常见的五种IO模型：
1. 阻塞IO:两阶段都阻塞
2. 非阻塞IO:第一阶段不阻塞，第二阶段阻塞，忙询(占用CPU资源)
3. IO多路复用:select/poll/epoll(单个线程/进程可监听多个文件描述符)
4. 信号驱动IO:第一阶段不阻塞，第二阶段阻塞
5. 异步IO:两阶段都是不阻塞的

### select/poll/epoll的区别 LT(水平触发模式)ET(边缘触发)
select和poll的区别其实不大，select可监听的文件描述符最大值是固定的，32位机默认是1024个。64位机默认是2048，而poll的文件描述符是由链表连接的数量不受限制。select和poll另外一个区别在于：select文件描述符集合不能重用，poll内核通过revents来设置事件是否触发，所以每次不需要重置。select和poll都是采用轮询的方式找文件描述符，时间复杂度太高，而且fd_set会在用户空间和内核空间来回拷贝，开销大，都只能采用LT模式。
epoll:底层是红黑树加双向链表，所以增删改的时间复杂度都是log(n)，通过epoll_create在内核创建一个新的创建eventpoll结构体，可以采用ET模式和LT两种模式（**epoll工作在ET模式的时候，必须使用非阻塞接口，以避免由一个文件句柄的阻塞读/写操作 而把多个文件描述符的任务饿死。**）
LT:只要缓冲区有数据就会一直通知用户
ET:当缓冲区的数据从无到有时通知一次用户，当数据改变时通知一次用户，其他时候不通知用户

**注意监听socket不要使用epolloneshot** 编写过程的一个bug



### webbench的原理
通过父进程fork()创建子进程，然后子进程对目标web循环访问设定的时间，然后通过管道传出访问的的信息。
以下是webbench的测试压力截图
![](http://sad.qcemo.cn/myblog/image/1649400703783_sad1.png)

![](http://sad.qcemo.cn/myblog/image/1649400712812_sad2.png)

![](http://sad.qcemo.cn/myblog/image/1649400725521_sad3.png)
